\documentclass[11pt,a4paper]{article}


\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}


\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{physics}
\usepackage{bm}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, urlcolor=blue}

\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\theoremstyle{plain}
\newtheorem{theorem}{Теорема}[section]
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{prop}[theorem]{Утверждение}

\theoremstyle{definition}
\newtheorem{definition}{Определение}[section]
\newtheorem{example}{Пример}[section]

\theoremstyle{remark}
\newtheorem{remark}{Замечание}[section]

\usepackage[backend=biber,style=numeric,sorting=nyt]{biblatex}
\addbibresource{refs.bib} 

\usepackage{authblk}
\title{Почти гарантированная доставка в garbled circuit}
\author[1]{Светлицкий Михаил}
\affil[1]{e-mail: \texttt{minkal2sh@gmail.com}}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
В данной работе описывается алгоритм почти гарантированной доставки в модели garbled circuit. Под почти гарантированной мы подразумеваем что в худшем случае злоумышленник может получить преемущество в два раза во времени получения ответа. Алгоритм состоит из двух частей: модификация исходного circuit для последующего перехода в SPDZ-sharing, и процедура раскрытия шэров Алисы и Боба для обеспечения почти гарантированной доставки. 
\end{abstract}

\tableofcontents
\clearpage

\section{Введение}
\label{sec:intro}

Современные протоколы безопасных вычислений позволяют нескольким сторонам совместно вычислять функции от их приватных данных без раскрытия этих данных друг другу. Одним из наиболее известных подходов является \emph{garbled circuit} (GC), предложенный Яо [1]. В двухсторонней вычислительной модели (\emph{2-party computation}, 2PC) одна сторона, Алиса, играет роль \emph{garbler}, создавая зашифрованную схему, а другая сторона, Боб, является \emph{evaluator}, вычисляющим результат на основе шифрованной схемы.

Несмотря на широкое распространение GC, возникают определённые проблемы, связанные с гарантией получения корректного результата. В классическом подходе одна из сторон первым получает результат вычислений, что создаёт потенциал для атак, например, для публикации ложных значений или задержки раскрытия результата. В контексте критически важных приложений (финансовые вычисления, распределённое голосование, протоколы с ограниченным временем реакции) такие ситуации недопустимы.

Кроме того классический результат Фишера, Линча и Патерсона [2] демонстрирует, что в распределённых системах невозможно достичь гарантированной доставки при наличии хотя бы одного ненадёжного процесса. 

В данной работе рассматривается алгоритм \emph{почти гарантированной доставки} результата GC, который обеспечивает:

\begin{itemize}
    \item защиту от намеренного обмана со стороны любой из сторон;
    \item возможность корректного получения результата обеими сторонами даже при попытках частичного мошенничества;
    \item ограничение вычислительного преимущества злоумышленника до не более чем двухкратного ускорения по сравнению с честной стороной;
\end{itemize}

Алгоритм состоит из двух логических частей:
\begin{enumerate}
    \item Модификация исходного garbled circuit для последующего перехода к SPDZ-sharing. Это позволяет преобразовать зашифрованный ответ в форму, удобную для поэтапного раскрытия и проверки корректности.
    \item Процедура поочередного раскрытия шэров Алисы и Боба, включающая MAC-check'и для проверки достоверности каждого бита. Такая процедура обеспечивает почти гарантированную доставку даже в условиях частичного мошенничества.
\end{enumerate}


\section{Переход от GC к SPDZ-sharing}
\label{subsec:gc-to-spdz}

В дальнейшем будем сокращать \emph{garbled circuit} до \emph{GC}. Предполагается, что Алиса играет роль \emph{garbler}, а Боб --- \emph{evaluator}. Также считаем, что по завершении исходной схемы GC выдаёт \emph{незапутанный} (то есть не зашифрованный) ответ, и первым этот ответ получает Боб.

Для корректного последующего раскрытия значений на фазе SPDZ потребуется серия \emph{MAC-check'ов}. Мы будем использовать MAC-check'и над битами, то есть над полем $\mathbb{F}_2$, и применять метод, описанный в работе в работе [3], с рядом упрощений процедуры раскрытия, обусловленных тем, что мы находимся в модели двухсторонних вычислений (2PC), а не в общем MPC.

Как именно мы хотим модифицировать оригинальную GC? 
Во-первых, мы хотим возвращть \emph{зашифрованный} ответ исходной GC, дополненный несколькими нулями, которые в будущем будут служить сигнализационным механизмом того, что расшифровка была произведена корректно. Кроме того, модернизированная GC должна возвращать только \emph{шар Боба} (его часть) от зашифрованного ответа, а также его часть MAC-check'ов. Шары Алисы известны ей заранее. Для этого необходимо добавить несколько дополнительных входов.

\subsection{Структура входов и вычисления внутри модернизированного GC}

Зафиксируем параметр безопасности $s$. Чем он больше, тем надёжнее выполняются MAC-check'и.

\paragraph{Входы Алисы.}
Для каждого бита (предполагаем, что их $n$) ответа оригинальной схемы GC Алиса генерирует случайным образом:
\begin{itemize}
    \item битовую строку длины $s+1$, которая будет её шаром ответа $[enc(x)]$;
    \item битовую строку длины $s$, которая будет её шаром MAC-ключа $[a]$;
    \item битовую строку длины $s+1$, которая будет её шаром ответа $[xa]$.
\end{itemize}
Все эти данные Алиса подаёт в модернизированную GC.

\paragraph{Входы Боба.}
Боб, для каждого бита исходного ответа, генерирует случайным образом:
\begin{itemize}
    \item битовую строку длины $s$, являющуюся его шаром $[a]$;
    \item битовую строку длины $s$, представляющую старшие биты его шара $[x]$ (младшие биты будут вычислены внутри схемы).
\end{itemize}
Остальные необходимые шары Боб получит непосредственно из выполнения GC.

\paragraph{Общий ключ шифрования.}
Алиса и Боб договариваются о симметричном ключе шифрования, известном обоим участникам. Этот ключ также подан в схему (для упрощения секркута считаем, что это делает Алиса).

\subsection{Вычисления внутри модернизированной GC.}
В начале работы модернизированная GC полностью вычисляет исходную GC и получает её ответ $x$. Далее выполняются следующие шаги:
\begin{enumerate}
    \item Значение $x$ дополняется заданным числом нулей (индикатор верной расшифроки в будущем) шифруется с использованием согласованного ключа, что даёт $enc(x)$.
    \item Необходимо выполнить SPDZ-sharing значения $enc(x)$. Для этого берутся по 1 младшему биту из каждой битовой строки Алисы и выполняется операция XOR с $enc(x)$. Полученные биты являются младшими битами шара Боба от $enc(x)$. Объединяя их с битовыми строками, поданными Бобом, получаем полный шар Боба от $enc(x)$, который возвращается в выход схемы.
    \item Вычисляются MAC-check'и. Сначала складываются шары MAC-ключа Алисы и Боба, поданные ими на вход:
    \[
        a = a_1 + a_2 \bmod 2^{s+1},
    \]
    получая общий MAC-ключ $a$.
    \item Затем вычисляется произведение:
    \[
        a \cdot enc(x) \bmod 2^{s+1}.
    \]
    \item Вычитая из $a \cdot enc(x) \bmod 2^{s+1}$ выходные строки Алисы (также по модулю $2^{s+1}$), получаем шар Боба от $[xa]$, который также подаётся в выход схемы.
\end{enumerate}

\paragraph{Результат выполнения модернизированного GC.}
После завершения схемы:
\begin{itemize}
    \item Алиса знает свои шары от $[enc(x)]$, $[a]$, $[xa]$, так как она сама их сгенерировала и подала в GC.
    \item Боб знает свой шар от $[a]$ и получает из GC свой шар от $[enc(x)]$ и $[xa]$.
\end{itemize}

Таким образом, стороны переходят в состояние SPDZ-sharing относительно значений $[enc(x)]$, $[a]$ и $[xa]$.

Несомненным преимуществом данного подхода является то, что Бобу на текущем этапе не требуется ничего публиковать. Следовательно, у него отсутствует возможность обмануть Алису, предоставив правдоподобно выглядящие, но ложные результаты.

\section{Раскрытие шаров Алисы и Боба}
\label{sec:reveal-shares}

На данном этапе мы находимся в модели SPDZ-sharing по модулю $2$ и располагаем $n$ зашаренными битами зашифрованного ответа. Для этих битов уже вычислены MAC-check'и. Симметричный ключ известен и Алисе, и Бобу, поэтому после полного раскрытия всех битов зашифрованного ответа обе стороны смогут расшифровать его и получить исходный ответ.

\subsection{Идея алгоритма}

Ключевая идея алгоритма заключается в том, что Алиса и Боб раскрывают биты поочередно, проверяя на каждом этапе, что никто не обманывает другую сторону. 

\subsection{Пошаговая процедура}

Процедура раскрытия выполняется следующим образом:

\begin{enumerate}
    \item Алиса публикует свой шар $i$-го бита.
    \item Боб публикует свой шар того же бита.
    \item Производится проверка корректности с помощью MAC-check'ей: обе стороны раскрывают соответствующие шары $[xa]$ и сравнивают их с $[x] \cdot [a]$. 
    \begin{itemize}
        \item Если равенство выполняется, алгоритм продолжается к следующему биту.
        \item Если равенство не выполняется, значит кто-то попытался обмануть, и взаимодействие немедленно прекращается.
    \end{itemize}
\end{enumerate}

Таким образом, биты раскрываются последовательно. Если на каждом этапе никто не нарушает протокол, то в конце алгоритма как Алиса, так и Боб получают правильный ответ.

\subsection{Гарантия почти гарантированной доставки}

Если на каком-либо этапе одна из сторон начинает отправлять неверные данные или перестаёт взаимодействовать, то в лучшем случае мошенник получает на один бит правильного ответа больше, чем честная сторона. Благодаря индикатору корректной расшифровки который мы добавили ранее, оставшийся суффикс приходится можно найти через полный перебор, что требует вдвое больше вычислительных усилий для обманутой стороны, чем для мошенника. Таким образом достигается свойство \emph{почти гарантированной доставки}.

\section*{Список литературы}

\begin{thebibliography}{99}

\bibitem{yao1986}
A.~C.-C.~Yao,  
\emph{How to Generate and Exchange Secrets},  
in Proceedings of the 27th Annual Symposium on Foundations of Computer Science (FOCS), 1986, pp. 162--167, IEEE, doi:10.1109/SFCS.1986.25.

\bibitem{FLP85}
Michael~J.~Fischer, Nancy~A.~Lynch, Michael~S.~Paterson,  
\emph{Impossibility of distributed consensus with one faulty process},  
Journal of the ACM (JACM), 32(2):374--382, 1985.

\bibitem{CramerDamgardEscuderoSchollXing2018}
Ronald~Cramer, Ivan~Damgård, Daniel~Escudero, Peter~Scholl, Chaoping~Xing,  
\emph{SPDZ2k: Efficient MPC mod \(2^k\) for Dishonest Majority},  
Cryptology ePrint Archive, Report 2018/482, 2018.

\end{thebibliography}


\end{document}
